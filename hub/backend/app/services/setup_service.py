"""
Setup service - Clones CommandCenter and configures it for a project
"""

import os
import subprocess
import secrets
from pathlib import Path

from app.models import Project


class SetupService:
    """Service for setting up new CommandCenter instances"""

    # Local CommandCenter source (with latest updates)
    CC_SOURCE = "/Users/danielconnolly/Projects/CommandCenter"

    async def setup_commandcenter(self, project: Project) -> None:
        """
        Setup CommandCenter for a project

        Steps:
        1. Copy CommandCenter from local source
        2. Create .env file with unique configuration
        3. Create necessary directories
        """
        # Copy CommandCenter from local source
        await self._copy_commandcenter(project.cc_path)

        # Generate .env file
        await self._generate_env_file(project)

        # Create data directories
        await self._create_directories(project.cc_path)

    async def _copy_commandcenter(self, cc_path: str) -> None:
        """Copy CommandCenter from local source"""
        if os.path.exists(cc_path):
            # Already exists, skip
            return

        # Ensure source exists
        if not os.path.exists(self.CC_SOURCE):
            raise RuntimeError(f"CommandCenter source not found at {self.CC_SOURCE}")

        try:
            # Use rsync to copy, excluding .git, node_modules, venv, etc.
            result = subprocess.run(
                [
                    "rsync",
                    "-av",
                    "--exclude=.git",
                    "--exclude=node_modules",
                    "--exclude=venv",
                    "--exclude=__pycache__",
                    "--exclude=*.pyc",
                    "--exclude=.env",
                    "--exclude=rag_storage",
                    "--exclude=backups",
                    "--exclude=hub",
                    f"{self.CC_SOURCE}/",
                    cc_path,
                ],
                capture_output=True,
                text=True,
                timeout=300,
            )

            if result.returncode != 0:
                raise RuntimeError(f"Failed to copy CommandCenter: {result.stderr}")

        except Exception as e:
            raise RuntimeError(f"Failed to copy CommandCenter: {str(e)}")

    async def _generate_env_file(self, project: Project) -> None:
        """Generate .env file with project-specific configuration"""
        env_path = os.path.join(project.cc_path, ".env")

        # Generate secrets
        secret_key = secrets.token_hex(32)
        db_password = secrets.token_urlsafe(32)

        env_content = f"""# CommandCenter Configuration
# Auto-generated by Hub for project: {project.name}
# Generated: {project.created_at}

# Project Isolation
COMPOSE_PROJECT_NAME={project.compose_project_name}

# Ports
BACKEND_PORT={project.backend_port}
FRONTEND_PORT={project.frontend_port}
POSTGRES_PORT={project.postgres_port}
REDIS_PORT={project.redis_port}

# Security
SECRET_KEY={secret_key}
DB_PASSWORD={db_password}
ENCRYPT_TOKENS=true

# Database
DATABASE_URL=postgresql://commandcenter:${{DB_PASSWORD}}@postgres:{project.postgres_port}/commandcenter

# Redis & Celery
REDIS_URL=redis://redis:{project.redis_port}
CELERY_BROKER_URL=redis://redis:{project.redis_port}/0
CELERY_RESULT_BACKEND=redis://redis:{project.redis_port}/0

# Optional: Add your API keys here
# GITHUB_TOKEN=ghp_...
# ANTHROPIC_API_KEY=sk-ant-...
# OPENAI_API_KEY=sk-...

# CORS
CORS_ORIGINS=["http://localhost:{project.frontend_port}"]

# Frontend Configuration
VITE_PROJECT_NAME={project.name}
"""

        try:
            with open(env_path, "w") as f:
                f.write(env_content)
        except Exception as e:
            raise RuntimeError(f"Failed to write .env file: {str(e)}")

    async def _create_directories(self, cc_path: str) -> None:
        """Create necessary data directories"""
        directories = [
            os.path.join(cc_path, "rag_storage"),
            os.path.join(cc_path, "backups"),
            os.path.join(cc_path, "hub_data"),
        ]

        for directory in directories:
            os.makedirs(directory, exist_ok=True)
