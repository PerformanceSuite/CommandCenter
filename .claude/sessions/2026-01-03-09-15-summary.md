# Session Summary: AutoCoder API Design

**Date:** 2026-01-03 09:15
**Task:** Add FastAPI routes for AutoCoder module

## Accomplished

- Reviewed last commit (Auto-Claude integration complete)
- Explored AutoCoder module structure:
  - `task_manager.py` - orchestrates tasks through The Loop
  - `base.py` - LoopContext and BaseAdapter
  - `api/__init__.py` - empty, ready for routes
- Started brainstorming API design
- Identified key question: sync vs async vs WebSocket

## Key Components Discovered

```
hub/modules/auto-coder/src/
├── adapters/
│   ├── base.py       # LoopContext, BaseAdapter
│   ├── discover.py   # DISCOVER phase
│   ├── validate.py   # VALIDATE phase
│   └── improve.py    # IMPROVE phase
├── orchestrator/
│   └── task_manager.py  # AutoCoderTaskManager
├── api/
│   └── __init__.py   # EMPTY - needs routes
└── cli/
    └── __init__.py   # Future CLI commands
```

## Key Classes

- `AutoCoderTaskManager`: async methods for create_task, run_task, get_status, list_tasks
- `CodingTask`: id, description, project_dir, complexity, status, parallel_agents
- `TaskResult`: task_id, success, context, message
- `LoopContext`: task_id, project_dir, spec_dir, phase, memory, sandbox_id, artifacts

## Decisions Pending

**API Architecture Options:**
1. Synchronous - POST blocks until completion
2. Async with polling - POST returns immediately, GET for status
3. WebSocket streaming - Real-time phase updates (recommended)

## Next Steps

1. Get user decision on sync/async/websocket approach
2. Design API routes based on chosen approach
3. Implement FastAPI router in `api/__init__.py` or `api/routes.py`
4. Add Pydantic schemas for request/response models
5. Wire up to task manager

## Resume Context

We were in brainstorming mode for the FastAPI API design. The core task manager exists with async methods. The next step is to decide on the API pattern (sync/async/websocket) and then implement the routes. User was presented with three options for the API architecture pattern.
